/* eslint complexity: "off" */
// Targets modern platforms
// @see: https://math.stackexchange.com/questions/2678480/formula-for-a-stadium-shape-2d-capsule
var vectorMath = {
  add: function(vectorA, vectorB) {
    return {
      x: vectorA.x + vectorB.x,
      y: vectorA.y + vectorB.y
    };
  },
  /**
  * @function subtract
  * @description Subtracts vectorB from vectorA and returns the difference
  * @param {object} vectorA
  *   @param {number} vectorA.x
  *   @param {number} vectorA.y
  * @param {object} vectorB
  *   @param {number} vectorB.x
  *   @param {number} vectorB.y
  * @returns {object} A vector that represents the difference between vectorA and vectorB
  */
  subtract: function(vectorA, vectorB) {
    return {
      x: vectorA.x - vectorB.x,
      y: vectorA.y - vectorB.y
    };
  },
  /**
  * @function perpendicular
  * @description Returns the given vector's perpendicular vector, since the polygon is generated by clockwise vertices, x and y is flipped, with the new y being negative.
  * @param {object} vector Vector to make perpendicular
  *   @param {number} vector.x
  *   @param {number} vector.y
  * @returns {object} The vector perpendicular to the given vector
  */
  perpendicular: function(vector) {
    return {
      x: -vector.y,
      y: vector.x
    };
  },
  negate: function(vector) {
    return {
      x: -vector.x,
      y: -vector.y
    };
  },
  normalize: function(vector) {
    var length = Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2));

    return {x:
      vector.x / length,
    y: vector.y / length
    };
  },
  dot: function(vectorA, vectorB) {
    return (vectorA.x * vectorB.x) + (vectorA.y * vectorB.y);
  },
  cross: function(vectorA, vectorB) {
    return (vectorA.x * vectorB.y) - (vectorA.y * vectorB.x);
  },
  divide: function(vector, number) {
    return {
      x: vector.x / number,
      y: vector.y / number
    };
  },
  multiply: function(vector, multiplier) {
    return {
      x: vector.x * multiplier,
      y: vector.y * multiplier
    };
  }
};

// assumes {x: 0, y: 0} objects
function getCentroid(points) {
  var centroid;
  var sumX = 0;
  var sumY = 0;

  if (points instanceof Array) {
    points.forEach(function(element) {
      // Skip non-points
      if (typeof element.x !== 'number' || typeof element.y !== 'number') {
        return;
      }

      sumX += element.x;
      sumY += element.y;
    });

    centroid = {
      x: sumX / points.length,
      y: sumY / points.length
    };
  }

  return centroid;
}

// segment is an array of two points
// @see: https://stackoverflow.com/questions/14307158/how-do-you-check-for-intersection-between-a-line-segment-and-a-line-ray-emanatin
function rayCastSegment(rayOrigin, angle, segment) {
  var r = {x: Math.cos(angle), y: Math.sin(angle)};
  var t0;
  var t1;
  var qp = vectorMath.subtract(segment[0], rayOrigin);

  var s = vectorMath.subtract(segment[1], segment[0]);
  var rs = vectorMath.cross(r, s);

  // Find scalar values for both ray and segment
  var t = vectorMath.cross(qp, s) / rs; // Scalar for ray (This seems to be the broken one)
  var u = vectorMath.cross(qp, r) / rs; // Scalar for Segment

  var rayPoint = vectorMath.add(rayOrigin, vectorMath.multiply(r, t));
  var segPoint = vectorMath.add(segment[0], vectorMath.multiply(s, u));

  var validRayPoint = isFinite(rayPoint.x) && isFinite(rayPoint.y);
  var validSegPoint = isFinite(segPoint.x) && isFinite(segPoint.y);

  // Round vectors to 4 decimal places
  rayPoint.x = Math.round(rayPoint.x * 1000) / 1000;
  rayPoint.y = Math.round(rayPoint.y * 1000) / 1000;

  segPoint.x = Math.round(segPoint.x * 1000) / 1000;
  segPoint.y = Math.round(segPoint.y * 1000) / 1000;

  if (t < 0 || (u > 1 || u < 0)) {
    return;
  }

  // Both must be valid points, otherwise they never intersect
  if (validRayPoint && validSegPoint) {
    // If coordinate values are same, return intersection point
    if (rayPoint.x === segPoint.x && rayPoint.y === segPoint.y) {
      return rayPoint;
    }
  }

  return;

  /*
  NOTE: This actually assumes both lines are segments!
  // Collinear (share a line)
  if (vectorMath.cross(r, s) === 0 && vectorMath.cross(vectorMath.subtract(segment[0], rayOrigin), r) === 0) {
    console.log('collinear check');
    t0 = vectorMath.cross(vectorMath.subtract(segment[0], rayOrigin), r / vectorMath.cross(r, r));
    t1 = t0 + s * vectorMath.divide(r, vectorMath.cross(r, r));

    if (t0 < 1 && t1 < 0) {
      return vectorMath.add(rayOrigin, vectorMath.multiply(r, t));
    } else {
      return;
    }
  } else if (rs === 0 && vectorMath.cross(qp, r) == 0) {
    console.log('parallel: no intersection');
    return;
  } else if (rs !== 0 && (0 <= t && t <= 1) && (0 <= u && u <= 1)) {
    console.log('Intersects');
    return vectorMath.add(rayOrigin, vectorMath.multiply(r, t));
  } else {
    console.log('No intersection');
    return;
  }
  */
}

function DSCarousel(DOMTarget, options) {
  var defaults = {

  };

  this.DOMTarget = DOMTarget;
  this.direction = 0; // Degrees
  this.x = 0;
  this.y = 0;
  this.progress = 0;
  this.length = 0; // Width of items total + padding;
  this.padding = 0;
  this.minSlides = 2;
  this.angleOffset = 0;
  this.angleCurrent = 0;

  this.DOMTarget.style.transform = 'translate3d(0,0,0.01px)';
  // Potentially doesn't fix looping if there's less than 3 slides
  this.polygon = [
    {x: -this.DOMTarget.clientWidth, y: 0},
    {x: this.DOMTarget.clientWidth * 2, y: 0},
    {x: this.DOMTarget.clientWidth * 2, y: -this.DOMTarget.clientWidth * 3},
    {x: -this.DOMTarget.clientWidth, y: -this.DOMTarget.clientWidth * 3}
  ];
  this.centroid = getCentroid(this.polygon);

  // BEGIN: Init
  this.update();
  // END: Init

  // Given a number of slides...

  //console.log(a);
}

DSCarousel.prototype = {
  update: function() {
    // DOM
    var DOMChildren = this.DOMTarget.children;
    var DOMChild;
    // LOGIC
    var _this = this;
    var s = 0;
    var polygon = this.polygon;
    var newPositionTemp;
    var newPosition;
    var offset;
    var newSearch = true;

    this.angleCurrent += this.angleOffset;
    this.angleCurrent = this.angleCurrent >= 360 ? 0 : this.angleCurrent;

    for (s = 0; s < DOMChildren.length; s++) {
      DOMChild = DOMChildren[s];
      offset = 360 / DOMChildren.length * (s - 1);
      polygon.forEach(function(element, index) {
        var segA = element;
        var segB = (index + 1) === polygon.length ? polygon[0] : polygon[index + 1];

        newPosition = rayCastSegment(_this.centroid, Math.PI / 180 * (_this.angleCurrent + offset), [segA, segB]);

        if (newSearch && typeof newPosition !== 'undefined') {
          newSearch = false;
          DOMChild.style.transform = 'translate3d(' + (newPosition.x - _this.DOMTarget.clientWidth/2) + 'px, 0px, ' + newPosition.y + 'px)';
          if (newPosition.y < 0) {
            DOMChild.style.opacity = 0;
          } else {
            DOMChild.style.opacity = 1;
          }
        }
      });

      newSearch = true;
    }
  },
  setAngle: function(angleNew) {
    this.angleCurrent = angleNew;
    this.update();
  }
};
